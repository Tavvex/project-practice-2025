Из репозитория [How to build your own X](https://github.com/codecrafters-io/build-your-own-x) наша команда выбрала разработку собственного чат-бота для мессенджера Telegram. Для написания кода для бота был выбран стек **aiogram**, который является самым популярным стеком для создания телеграмм-ботов, благодаря поддержки асинхронности.
Бота, созданного в рамках выполнения вариативного задания для Проектной Практики, мы назвали **ToYouFromNow**. Наш проект представляет собой аналог сайта *FutureMe* в обёртке телеграмм-бота, который позволяет пользователю отправить сообщения "в будущее" и пользователь получит их обратно в выбранное время.
Для создания бота мы изучили [видео-курс на YouTube](https://youtube.com/playlist?list=PLV0FNhq3XMOJ31X9eBWLIZJ4OVjBwb-KM&si=UNVpkD7pILl1XS4C) по созданию телеграмм-ботов на aiogram 3.0 от *sudo teach IT*. Следую инструкции из видео-уроков мы создали рабочего бота, отвечающий на сообщения пользователей, имеющий фоновый процесс и работающий с БД. Исходный код нашего проекта можно посмотреть в папке *src*.
## Туториал по созданию телеграмм-бота.
Для выполнения задания по Проектной практике мы написали туториал для начинающих, который позволит каждому создать своего бота, зная азы языка программирования *Python*. Руководство разбито на несколько последовательных шагов для удобства читающего.
### 1. Получение токена
Для работы бота в Telegram необходим токен - уникальный ключ, который используется для аутентификации и идентификации бота. Токен можно получить в чате с телеграмм-ботом **@BotFather**, написав команду */newbot*.

![[token.jpg]]

После ввода имени бота и его юзернейма, вы получите тот самый **токен**.

> [!NOTE] Важно!
> Через токен третьи лица могут управлять вашим ботом, редактировать его и в итоге украсть его! Не показывайте токен кому-либо, кроме членов вашей команды разработки. В дальнейшем будет рассказано как скрыть токен в исходном коде вашего бота. Если так случилось, что кто-то посторонний получил доступ к коду, то смените токен через BotFather, введя команду /mybots -> API Token -> Revoke current token.


### 2. Загрузка библиотек
Важная часть любой разработки на *Python* - **библиотеки**.
Загрузить библиотеку можно при помощи консоли через **установщик пакетов Python**.
Пример команды для установки библиотек:

```bash
pip install aiogram
```

Для разработки бота понадобятся следующие библиотеки:
- aiogram
- asyncio
- sqlaclhemy
- dotenv

Также пользователи среды разработки *PyCharm* могут подгружать необходимые через инструменты этой среды(Settings -> Project -> Python Intepreter -> *нажать плюсик(+)* -> *выбрать библиотеку* -> Install Package)

![[pycharm.png]]

### 3. Скелет бота и скрытие токена
Создав новый .py-файл,например *main.py*, в проекте импортируем необходимые на данные этапы библиотеки.

```Python
import asyncio
from aiogram import Bot, Dispatcher
from dotenv import load_dotenv
import os
```

Ранее упоминалось, что токен не стоит вставлять напрямую в код проекта, особенно, в OpenSource, загруженный в публичный  удалённый репозиторий на GitHub. Всю конфиденциальную информацию, включаю ключи API - токены, программисты хранят в файлах окружения формата **.env**. В папке с проектом нужно создать файл с расширением .env. Файл окружения хранит информацию в парах ключ-значение. Ключ принято называть заглавными буквами **TOKEN**, и через оператор присваивания(=) записывается токен. Теперь 
в коде проекта вместо настоящего токена, будем писать ключ TOKEN.

```env
TOKEN='ваш токен'
```

Вернёмся в *main.py*. Функцией *load_dotenv()* загружаем токен. Затем создаём объект класса Bot, в аргумент которого пишем *os.getenv('TOKEN')*. Наконец, создаём объект класса Dispatcher. 

```Python
load_dotenv()  
bot = Bot(os.getenv('TOKEN'))  
dp = Dispatcher()
```

Далее нужно описать функцию main, которая будет служить точкой входа при запуске бота. В этой функции нужно запустить **поллинг** - регулярное взаимодействие между ботом и пользователем. Важно! Поллинг в aiogram - асинхронная функция, и все асинхронные функции нужно вызывать с ключевым словом **await** (есть одно исключение, о которым мы упомянем отдельно).

```Python
async def main():
	await dp.start_polling(bot)


if __name__ == '__main__':  
    try:  
        asyncio.run(main())  
    except KeyboardInterrupt:  
        print("Exit")

```

### 4. Обработка сообщений
Чтобы наш бот заговорил используются **обработчики**(*handlers*). Для обработчиков создадим новый .py-файл, назовём *handlers.py*. Импортируем нужные библиотеки и модули:

```Python
from aiogram import Router, Bot  
from aiogram.filters import CommandStart, Command  
from aiogram.types import Message
```

Диспетчер нельзя импортировать в другой файл из main.py, поэтому в файле handlers.py мы создадим аналог диспетчера - **роутер**. По сути, диспетчер просто является главным роутером, остальные роутеры используется, если диспетчер не смог обработать сообщение от пользователя.

```Python
router = Router()
```

Разберём пример обработчика, который отправляет сообщение пользователю при старте бота, или отправки команды */start*

```Python
@router.message(CommandStart())  
async def start(message: Message):  
    await message.answer('sup <3! Этот бот позволяет отправить письмо себе в будущее! Хочешь попробовать? напиши команду'  
                         ' /help, чтобы узнать доступные команды')
```

В аргументах декоратора @router.message() указывается при обработке какой команды, следующая функция вызовется. Для обработки старта бота есть отдельная функция *CommandStart()*, для обработки других команд в аргументах декоратора пишется функция Command() с аргументом в виде строки без слеша, например для обработки команды /help будет выглядеть так: `Command('help')`.
После объявления декоратора создаётся асинхронная функция с объектом класса **Message** в аргументе. Для отправки сообщения у этого объекта вызываем метод **answer**, в аргументах которого пишем нужное сообщение для отправки пользователю. Метод асинхронный, поэтому перед ним ставим *await*.
Последний штрих - перейти обратно в файл *main.py*, импортируем *router* из файла *handlers*, а в функцию *main* пишем *dp.include_router(router)*.

```Python
from handlers import router
...
async def main():
	dp.include_router(router)   
	await dp.start_polling(bot)
```

Готово! Наш бот теперь нам отвечает.

![[handlers.png]]
 
### 5. Конечный автомат состояний (FSM)
Во время разработки бота возникнет необходимость получать информацию от пользователя, например, для регистрации или сохранения в БД. Возникают трудности, как дать понять боту что в этом сообщении - логин, а в другом - номер телефона? Для этого используется **FSM**. 
Начнём с импорта нужных модулей в *handlers.py*.

```Python
from aiogram.fsm.state import StatesGroup,State  
from aiogram.fsm.context import FSMContext
```

Далее задаём состояние, какие будут использоваться в дальнейшем. Определение состояний записываем в отдельном классе. Например, для своего проекта нам важно было записывать от пользователя текст сообщения и дату, когда оно придёт пользователю. Класс состояний должен быть подклассом **StatesGroup**, а состояния - объекты класса **State**.

```Python
class Parser(StatesGroup):   
    text = State()  
    date = State()  
```

Создадим обработчик для команды */send*. В аргументы функции добавляем объект класса **FSMContext**, через который и будут управлять состояниями. В этом обработчике меняем состояние на *text* асинхронной методом **set_state()**, а аргументе которого добавляем нужное состояние. 

```Python
@router.message(Command('send'))  
async def send(message: Message, state: FSMContext):  
    await state.set_state(Parser.text)  
    await message.answer("Отлично! Напиши сообщение, которое ты получишь в будущем! (>100 символов)")
```

Теперь в аргументе декоратора для следующего обработчика вместо сообщения и команд записываем состояние, которое мы установили ранее. После отправки сообщения пользователем, вызовется именно этот обработчик. Кстати, мы же хотели сохранить текст сообщения пользователя? Для сохранения данных используется метод **update_data**. После сохранения данных можно снова изменить состояние на следующее.

```Python
@router.message(Parser.text)  
async def getText(message: Message, state: FSMContext):  
    if (len(message.text) >= 100):  
        await state.update_data(text=message.text)  
        await state.set_state(Parser.date)  
        await message.answer('Золотые слова! Теперь напиши, когда ты снова увидешь своё сообщение.(Например, "через год", "через 3 месяца", "2026 год 3 сентября в 15:49")')  
    else:  
        await message.answer("Так мало слов! Уверен, тебе есть что сказать :D")

```

Чтобы получить записанные данные обратно в переменную, нужно использовать метод **get_data()**. Теперь полученные данные можно использовать дальше в коде: записать в базу данных или отправить их пользователю обратно. В конце нужно обязательно очистить данные **clear()**.

```Python
@router.message(Parser.date)  
async def getDate(message: Message, state: FSMContext,bot: Bot):  
    try:  
        await state.update_data(date=parse_date(message.text))  
        data = await state.get_data()  
        await addMessage(message.from_user.id, message.chat.id, data["date"], data["text"])  
        await message.answer(f"Увидимся {(data["date"]).strftime("%d %b %Y")} в {(data["date"]).strftime("%H:%M")} !")
        await state.clear()   
    except ValueError:  
        await message.answer("Ой! Не смог расспознать дату :<. Попробуй ещё раз!")

```

### 6. Работа с базой данных
В течение текущего учебного года мы изучали проектирование и устройство баз данных, инструменты для работы с ними, SQL, поэтому мы решили добавить в наш телеграмм-бот взаимодействие с базой данной.
Для телеграмм-бота, написанного на aiogramm, нужно использовать асинхронные функции для взаимодействия с БД. Для этого в расширениях для библиотеки sqlalchemy с asyncio. Код для взаимодействия баз данных разделим на 2 файла: первый - для подключения к БД, а второй - для запросов. В файл с подключением к БД подгружаем нужные модули.

```Python
from sqlalchemy import BigInteger, TIMESTAMP, Text  
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column  
from sqlalchemy.ext.asyncio import AsyncAttrs, async_sessionmaker, create_async_engine  
from datetime import datetime
```

После погрузки модулей нужно создать **асинхронный движок для работы с базой данных** при помощи функции *create_async_engine*. На основе этого движка создаётся подключение при помощи *async_sessionmaker()*.

```Python
engine = create_async_engine(url='sqlite+aiosqlite:///db.sqlite3')  
  
async_session = async_sessionmaker(engine)
```

Таблицы проектируется через классы-наследников от класса Base. Имя таблицы создаётся через присваивание переменной `__tablename__`, а атрибуты таблицы - через поля класса. Для таблицы обязателен первичный ключ!    

```Python
class Base(AsyncAttrs, DeclarativeBase):  
    pass  
  
class Message(Base):  
    __tablename__ = 'messages'  
    id: Mapped[int] = mapped_column(primary_key=True)  
    user_id: Mapped[int] = mapped_column(BigInteger)  
    chat_id: Mapped[int] = mapped_column(BigInteger)  
    sending_time: Mapped[datetime]= mapped_column(TIMESTAMP)  
    message_text: Mapped[str] = mapped_column(Text)  
    is_sent: Mapped[int] = mapped_column()
```

Функция **async_main()** нужна для запуска подключения к базе данных. Её импортируем в файл *main.py*, и вызываем в функции *main()*.

```Python
async def async_main():  
    async with engine.begin() as conn:  
        await conn.run_sync(Base.metadata.create_all)
```

```python
from databaseInterface import async_main
...
async def main():  
    await async_main()  
    dp.include_router(router)   
    await dp.start_polling(bot)  
```

Как упоминалось, запросы мы будем писать  в отдельном файле, например, request.py. Из предыдущего файла импортируем подключение и класс, описывающий таблицу.  SQL-запрос описывается как асинхронная функция, использующая асинхронное подключение. Для примера, метод *add* работает как *INSERT INTO* в языке SQL. После вызова метода *add* нужно вызвать асинхронный метод *commit*.

```Python
import datetime  
from databaseInterface import async_session  
from databaseInterface import Message  

async def addMessage(user_id: int,chat_id: int,sending_time: datetime,message_text: str):  
	async with async_session() as session:		       session.add(Message(user_id=user_id,chat_id=chat_id,sending_time=sending_time,message_text=message_text,is_sent=0))  
        await session.commit()
```

### 7. Фоновые процессы
Одна из самых частых задач для телеграмм-бота - отправлять какое-либо сообщение пользователю без предварительного сообщения от пользователя, например, рассылка всем пользователям бота или отправка сообщения, которое было сохранено в БД (как в нашем проекте).
Для начала создадим асинхронную функцию, которая работает пока глобальная переменная истинна. Чтобы не нагружать сервер функция повторяется с перерывом в какое-то время. Важно использовать именно асинхронную функцию sleep, так как обычная бы остановило выполнения остальных функций в коде. 
Далее в асинхронной функции, пусть будет *on_startup*,вызывается метод *create_task* с ранее написанной функции в аргументе. Важно! Среда разработки может выдавать предупреждение и настойчиво просить поставить *await* перед *asyncio.create_task*. Но ставить ненужно, ибо фоновый процесс не даст остальным функциям, как поллинг, работать. Также нужно описать функцию, которая будет вызываться после завершение работы бота. В ней переменной для бесконечного цикла присваивается false, чтобы прервать фоновый процесс без ошибок. Финальный штрих - в функции main() указать функции для старта и завершения фонового процесса методом *register*(). 

```python
stop_flag = True  
  
async def check_messages():  
    logger.info("Checking messages started")  
    while stop_flag:  
        ... //логика функции  
        await asyncio.sleep(60)  
  
  
async def on_startup():  
    asyncio.create_task(check_messages())  
  
  
async def on_shutdown():  
    stop_flag = False  
  
  
async def main():  
    await async_main()  
    dp.include_router(router)  
    dp.startup.register(on_startup)  
    await dp.start_polling(bot)  
    dp.shutdown.register(on_shutdown)
```